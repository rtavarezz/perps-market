// API Service Layer
//
// This module defines the interface between the trading engine and external systems.
// It provides a clean, typed API that can be adapted to REST, WebSocket, gRPC, or
// on chain program calls. The design follows a command/query separation pattern
// where commands mutate state and queries read it.
//
// The actual transport layer (HTTP server, blockchain runtime, etc) lives outside
// the core engine. This module just defines the contracts and request/response types.

use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};

use crate::types::{AccountId, OrderId, Side};
use crate::events::Event;
use crate::position::Position;
use crate::order::Order;

// All possible commands that can be sent to the engine.
// Each variant represents a distinct operation that mutates state.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum EngineCommand {
    // Create a new trading account
    CreateAccount {
        account_id: AccountId,
    },

    // Deposit collateral into an account
    Deposit {
        account_id: AccountId,
        amount: Decimal,
    },

    // Withdraw collateral from an account (must have no open positions)
    Withdraw {
        account_id: AccountId,
        amount: Decimal,
    },

    // Place a new order
    PlaceOrder {
        account_id: AccountId,
        side: Side,
        size: Decimal,
        /// None for market orders, Some(price) for limit orders
        limit_price: Option<Decimal>,
        /// If true, the order is post only and will be rejected if it would take
        post_only: bool,
        /// If true, the order must fill entirely or not at all
        fill_or_kill: bool,
        /// Client provided order ID for tracking (optional)
        client_order_id: Option<String>,
    },

    // Cancel an existing order
    CancelOrder {
        account_id: AccountId,
        order_id: OrderId,
    },

    // Cancel all orders for an account
    CancelAllOrders {
        account_id: AccountId,
    },

    // Update the oracle price (admin/keeper operation)
    UpdatePrice {
        price: Decimal,
        timestamp: u64,
        /// Optional source identifier for the price feed
        source: Option<String>,
    },

    // Settle funding payments (keeper operation)
    SettleFunding {
        /// Timestamp for funding calculation
        timestamp: u64,
    },

    // Attempt to liquidate an account (keeper/anyone operation)
    Liquidate {
        account_id: AccountId,
    },

    // Process auto deleveraging for a given bad debt amount (admin operation)
    ProcessAdl {
        bad_debt_amount: Decimal,
    },
}

// All possible queries that can be sent to the engine.
// Queries do not mutate state, just read it.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum EngineQuery {
    // Get account details including balance and positions
    GetAccount {
        account_id: AccountId,
    },

    // Get current position for an account
    GetPosition {
        account_id: AccountId,
    },

    // Get all open orders for an account
    GetOrders {
        account_id: AccountId,
    },

    // Get a specific order by ID
    GetOrder {
        order_id: OrderId,
    },

    // Get order book depth
    GetOrderBook {
        /// Max number of price levels per side
        depth: Option<usize>,
    },

    // Get current oracle price
    GetPrice,

    // Get market statistics
    GetMarketStats,

    // Get account margin details
    GetMarginInfo {
        account_id: AccountId,
    },

    // Check if an account can be liquidated
    CheckLiquidatable {
        account_id: AccountId,
    },

    // Get funding rate information
    GetFundingInfo,

    // Get recent events
    GetRecentEvents {
        /// Max number of events to return
        limit: Option<usize>,
    },
}

// Unified response wrapper for all API operations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ApiResponse<T> {
    pub success: bool,
    pub data: Option<T>,
    pub error: Option<ApiError>,
    // Events generated by this operation (for commands)
    pub events: Vec<Event>,
}

impl<T> ApiResponse<T> {
    pub fn ok(data: T) -> Self {
        Self {
            success: true,
            data: Some(data),
            error: None,
            events: Vec::new(),
        }
    }

    pub fn ok_with_events(data: T, events: Vec<Event>) -> Self {
        Self {
            success: true,
            data: Some(data),
            error: None,
            events,
        }
    }

    pub fn err(error: ApiError) -> Self {
        Self {
            success: false,
            data: None,
            error: Some(error),
            events: Vec::new(),
        }
    }
}

// Structured API error
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ApiError {
    pub code: ErrorCode,
    pub message: String,
    // Additional context for debugging
    pub details: Option<String>,
}

impl ApiError {
    pub fn new(code: ErrorCode, message: impl Into<String>) -> Self {
        Self {
            code,
            message: message.into(),
            details: None,
        }
    }

    pub fn with_details(mut self, details: impl Into<String>) -> Self {
        self.details = Some(details.into());
        self
    }
}

// Error codes for categorizing failures
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum ErrorCode {
    // Account errors
    AccountNotFound,
    AccountAlreadyExists,
    InsufficientBalance,
    InsufficientMargin,

    // Order errors
    OrderNotFound,
    OrderRejected,
    InvalidOrderSize,
    InvalidOrderPrice,
    WouldCross,

    // Position errors
    PositionNotFound,
    CannotWithdrawWithPosition,

    // Market errors
    MarketClosed,
    CircuitBreakerActive,
    InvalidPrice,

    // Liquidation errors
    NotLiquidatable,
    AlreadyLiquidated,

    // System errors
    InternalError,
    RateLimited,
    Unauthorized,
}

// Account information response
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AccountInfo {
    pub account_id: AccountId,
    pub balance: Decimal,
    pub equity: Decimal,
    pub unrealized_pnl: Decimal,
    pub available_margin: Decimal,
    pub position: Option<PositionInfo>,
    pub open_orders_count: usize,
}

// Position information response
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PositionInfo {
    pub side: Side,
    pub size: Decimal,
    pub entry_price: Decimal,
    pub mark_price: Decimal,
    pub unrealized_pnl: Decimal,
    pub liquidation_price: Option<Decimal>,
    pub leverage: Decimal,
}

impl From<&Position> for PositionInfo {
    fn from(pos: &Position) -> Self {
        let side = if pos.size.is_long() { Side::Long } else { Side::Short };
        Self {
            side,
            size: pos.size.abs(),
            entry_price: pos.entry_price.value(),
            mark_price: pos.entry_price.value(), // caller should update with actual mark
            unrealized_pnl: Decimal::ZERO, // caller should calculate
            liquidation_price: None, // caller should calculate
            leverage: Decimal::ZERO, // caller should calculate
        }
    }
}

// Order information response
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrderInfo {
    pub order_id: OrderId,
    pub account_id: AccountId,
    pub side: Side,
    pub size: Decimal,
    pub filled_size: Decimal,
    pub remaining_size: Decimal,
    pub price: Decimal,
    pub status: OrderStatus,
}

impl From<&Order> for OrderInfo {
    fn from(order: &Order) -> Self {
        Self {
            order_id: order.id,
            account_id: order.account_id,
            side: order.side,
            size: order.remaining_size, // Order only stores remaining
            filled_size: Decimal::ZERO, // Would need tracking
            remaining_size: order.remaining_size,
            price: order.price.map(|p| p.value()).unwrap_or(Decimal::ZERO),
            status: OrderStatus::Open,
        }
    }
}

// Order status
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum OrderStatus {
    Open,
    PartiallyFilled,
    Filled,
    Cancelled,
    Rejected,
}

// Order book level
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrderBookLevel {
    pub price: Decimal,
    pub size: Decimal,
    pub order_count: usize,
}

// Order book snapshot
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrderBookSnapshot {
    pub bids: Vec<OrderBookLevel>,
    pub asks: Vec<OrderBookLevel>,
    pub best_bid: Option<Decimal>,
    pub best_ask: Option<Decimal>,
    pub spread: Option<Decimal>,
    pub timestamp: u64,
}

// Market statistics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketStats {
    pub mark_price: Decimal,
    pub index_price: Decimal,
    pub open_interest_long: Decimal,
    pub open_interest_short: Decimal,
    pub volume_24h: Decimal,
    pub funding_rate: Decimal,
    pub next_funding_time: u64,
}

// Margin information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarginInfo {
    pub account_id: AccountId,
    pub collateral: Decimal,
    pub initial_margin: Decimal,
    pub maintenance_margin: Decimal,
    pub available_margin: Decimal,
    pub margin_ratio: Decimal,
    pub is_liquidatable: bool,
}

// Funding information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FundingInfo {
    pub current_rate: Decimal,
    pub predicted_rate: Decimal,
    pub last_settlement: u64,
    pub next_settlement: u64,
    pub funding_interval_hours: u32,
}

// Result of placing an order
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlaceOrderResult {
    pub order_id: OrderId,
    pub status: OrderStatus,
    pub filled_size: Decimal,
    pub remaining_size: Decimal,
    pub average_fill_price: Option<Decimal>,
    pub fills: Vec<FillInfo>,
}

// Individual fill information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FillInfo {
    pub price: Decimal,
    pub size: Decimal,
    pub fee: Decimal,
    pub counterparty: AccountId,
}

// Result of a deposit
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DepositResult {
    pub new_balance: Decimal,
    pub deposit_id: String,
}

// Result of a withdrawal
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WithdrawResult {
    pub new_balance: Decimal,
    pub withdrawal_id: String,
}

// Result of a liquidation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LiquidationResult {
    pub liquidated_account: AccountId,
    pub position_size: Decimal,
    pub liquidation_price: Decimal,
    pub bad_debt: Decimal,
    pub insurance_payout: Decimal,
}

// The main API service trait that defines the engine interface.
// Implementations can be synchronous (for testing) or async (for production).
pub trait EngineApi {
    // Execute a command that mutates engine state
    fn execute(&mut self, command: EngineCommand) -> ApiResponse<CommandResult>;

    // Execute a read only query
    fn query(&self, query: EngineQuery) -> ApiResponse<QueryResult>;
}

// Union type for command results
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum CommandResult {
    AccountCreated { account_id: AccountId },
    Deposited(DepositResult),
    Withdrawn(WithdrawResult),
    OrderPlaced(PlaceOrderResult),
    OrderCancelled { order_id: OrderId },
    AllOrdersCancelled { count: usize },
    PriceUpdated { price: Decimal },
    FundingSettled { accounts_affected: usize },
    Liquidated(LiquidationResult),
    AdlProcessed { accounts_affected: usize },
}

// Union type for query results
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum QueryResult {
    Account(AccountInfo),
    Position(Option<PositionInfo>),
    Orders(Vec<OrderInfo>),
    Order(Option<OrderInfo>),
    OrderBook(OrderBookSnapshot),
    Price { price: Decimal, timestamp: u64 },
    MarketStats(MarketStats),
    MarginInfo(MarginInfo),
    Liquidatable { is_liquidatable: bool },
    FundingInfo(FundingInfo),
    RecentEvents(Vec<Event>),
}

// Validates an incoming command before execution
pub fn validate_command(cmd: &EngineCommand) -> Result<(), ApiError> {
    match cmd {
        EngineCommand::Deposit { amount, .. } => {
            if *amount <= Decimal::ZERO {
                return Err(ApiError::new(
                    ErrorCode::InvalidOrderSize,
                    "Deposit amount must be positive",
                ));
            }
        }
        EngineCommand::Withdraw { amount, .. } => {
            if *amount <= Decimal::ZERO {
                return Err(ApiError::new(
                    ErrorCode::InvalidOrderSize,
                    "Withdrawal amount must be positive",
                ));
            }
        }
        EngineCommand::PlaceOrder { size, limit_price, .. } => {
            if *size <= Decimal::ZERO {
                return Err(ApiError::new(
                    ErrorCode::InvalidOrderSize,
                    "Order size must be positive",
                ));
            }
            if let Some(price) = limit_price {
                if *price <= Decimal::ZERO {
                    return Err(ApiError::new(
                        ErrorCode::InvalidOrderPrice,
                        "Limit price must be positive",
                    ));
                }
            }
        }
        EngineCommand::UpdatePrice { price, .. } => {
            if *price <= Decimal::ZERO {
                return Err(ApiError::new(
                    ErrorCode::InvalidPrice,
                    "Price must be positive",
                ));
            }
        }
        _ => {}
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_command_serialization() {
        let cmd = EngineCommand::PlaceOrder {
            account_id: AccountId(1),
            side: Side::Long,
            size: Decimal::new(1, 0),
            limit_price: Some(Decimal::new(50000, 0)),
            post_only: false,
            fill_or_kill: false,
            client_order_id: Some("my-order-1".to_string()),
        };

        let json = serde_json::to_string(&cmd).unwrap();
        assert!(json.contains("place_order"));
        assert!(json.contains("my-order-1"));

        let deserialized: EngineCommand = serde_json::from_str(&json).unwrap();
        match deserialized {
            EngineCommand::PlaceOrder { account_id, .. } => {
                assert_eq!(account_id, AccountId(1));
            }
            _ => panic!("Wrong variant"),
        }
    }

    #[test]
    fn test_query_serialization() {
        let query = EngineQuery::GetOrderBook { depth: Some(10) };
        let json = serde_json::to_string(&query).unwrap();
        assert!(json.contains("get_order_book"));
    }

    #[test]
    fn test_response_ok() {
        let response: ApiResponse<String> = ApiResponse::ok("success".to_string());
        assert!(response.success);
        assert_eq!(response.data.unwrap(), "success");
        assert!(response.error.is_none());
    }

    #[test]
    fn test_response_error() {
        let response: ApiResponse<String> = ApiResponse::err(
            ApiError::new(ErrorCode::AccountNotFound, "Account 123 not found")
                .with_details("Searched in active accounts"),
        );
        assert!(!response.success);
        assert!(response.data.is_none());
        let err = response.error.unwrap();
        assert_eq!(err.code, ErrorCode::AccountNotFound);
        assert!(err.details.is_some());
    }

    #[test]
    fn test_validate_deposit() {
        let valid = EngineCommand::Deposit {
            account_id: AccountId(1),
            amount: Decimal::new(1000, 0),
        };
        assert!(validate_command(&valid).is_ok());

        let invalid = EngineCommand::Deposit {
            account_id: AccountId(1),
            amount: Decimal::ZERO,
        };
        assert!(validate_command(&invalid).is_err());

        let negative = EngineCommand::Deposit {
            account_id: AccountId(1),
            amount: Decimal::new(-100, 0),
        };
        assert!(validate_command(&negative).is_err());
    }

    #[test]
    fn test_validate_order() {
        let valid = EngineCommand::PlaceOrder {
            account_id: AccountId(1),
            side: Side::Long,
            size: Decimal::new(1, 0),
            limit_price: Some(Decimal::new(50000, 0)),
            post_only: false,
            fill_or_kill: false,
            client_order_id: None,
        };
        assert!(validate_command(&valid).is_ok());

        let zero_size = EngineCommand::PlaceOrder {
            account_id: AccountId(1),
            side: Side::Long,
            size: Decimal::ZERO,
            limit_price: None,
            post_only: false,
            fill_or_kill: false,
            client_order_id: None,
        };
        assert!(validate_command(&zero_size).is_err());

        let bad_price = EngineCommand::PlaceOrder {
            account_id: AccountId(1),
            side: Side::Long,
            size: Decimal::new(1, 0),
            limit_price: Some(Decimal::new(-100, 0)),
            post_only: false,
            fill_or_kill: false,
            client_order_id: None,
        };
        assert!(validate_command(&bad_price).is_err());
    }

    #[test]
    fn test_error_codes() {
        let codes = vec![
            ErrorCode::AccountNotFound,
            ErrorCode::InsufficientBalance,
            ErrorCode::OrderRejected,
            ErrorCode::CircuitBreakerActive,
        ];

        for code in codes {
            let json = serde_json::to_string(&code).unwrap();
            let back: ErrorCode = serde_json::from_str(&json).unwrap();
            assert_eq!(back, code);
        }
    }
}
